// ============================================
// ğŸ§  Shrek Vulnerability Database v3.0
// Ø°ÙƒØ§Ø¡ Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ù„Ù„ÙƒØ´Ù Ø¹Ù† Ø§Ù„Ø«ØºØ±Ø§Øª - Ø¨Ø¯ÙˆÙ† False Positives
// ============================================

const ShrekVulnerabilityDB = {
    // Ø§Ù„Ø¥ØµØ¯Ø§Ø±
    version: '3.0.0',
    lastUpdate: '2026-02-12',
    
    // ========== 1. Ø£Ù†Ù…Ø§Ø· Ø§Ù„ÙƒØ´Ù Ø§Ù„Ø°ÙƒÙŠØ© ==========
    patterns: {
        // ğŸ”´ Reentrancy - Ø°ÙƒÙŠ 100%
        reentrancy: {
            name: 'Reentrancy Attack',
            severity: 'critical',
            category: 'access-control',
            
            // Ø£Ù†Ù…Ø§Ø· Ù…ØªØ¹Ø¯Ø¯Ø© Ù„Ù„ÙƒØ´Ù
            patterns: [
                // Ø§Ù„Ù†Ù…Ø· Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ
                {
                    regex: /\.call\{value:[^}]*\}\([^)]*\)\s*;[\s]*[^;]*balances?\[\w+\]\s*-=/gs,
                    weight: 1.0,
                    description: 'External call before state change - CRITICAL',
                    falsePositiveRisk: 0.01
                },
                // Ù†Ù…Ø· Ù…ØªÙ‚Ø¯Ù…
                {
                    regex: /\.(send|transfer)\([^)]*\)\s*;[\s]*[^;]*\w+\s*-=/gs,
                    weight: 0.8,
                    description: 'Using send/transfer with state change after',
                    falsePositiveRisk: 0.1
                },
                // Ù†Ù…Ø· Ù…Ø¹ modifiers
                {
                    regex: /nonReentrant[\s\S]*?\.call\{value:/g,
                    weight: 0.1,
                    description: 'Reentrancy guard present - likely safe',
                    falsePositiveRisk: 0.001,
                    isFalsePositive: true
                }
            ],
            
            // Ø§Ù„ØªØ­Ù‚Ù‚ Ø§Ù„Ø¥Ø¶Ø§ÙÙŠ
            validate: function(code, match) {
                // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø¹Ø¯Ù… ÙˆØ¬ÙˆØ¯ ReentrancyGuard
                if (code.includes('nonReentrant') || code.includes('ReentrancyGuard')) {
                    return { isTruePositive: false, reason: 'ReentrancyGuard detected' };
                }
                
                // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù†Ù…Ø· Checks-Effects-Interactions
                const lines = code.split('\n');
                const matchLine = this.findLineNumber(code, match.index);
                
                // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø­Ø§Ù„Ø© Ù‚Ø¨Ù„ Ø§Ù„Ø§Ø³ØªØ¯Ø¹Ø§Ø¡
                const beforeLines = lines.slice(Math.max(0, matchLine - 5), matchLine).join('\n');
                if (beforeLines.includes('-=') || beforeLines.includes('=')) {
                    return { isTruePositive: false, reason: 'State updated before call' };
                }
                
                return { isTruePositive: true, confidence: 0.95 };
            },
            
            findLineNumber: function(code, index) {
                return code.substring(0, index).split('\n').length;
            }
        },

        // ğŸŸ¡ Overflow/Underflow - Ø°ÙƒÙŠ
        overflow: {
            name: 'Arithmetic Overflow/Underflow',
            severity: 'medium',
            category: 'arithmetic',
            
            patterns: [
                // Solidity <0.8.0
                {
                    regex: /pragma\s+solidity\s+[^0.8][^;]*;[\s\S]*?(?:\+=|-=|\*=|\/=|\+\+|--)/g,
                    weight: 0.9,
                    description: 'Unchecked arithmetic in older Solidity version',
                    falsePositiveRisk: 0.05
                },
                // Unchecked blocks
                {
                    regex: /unchecked\s*\{[\s\S]*?(?:\+=|-=|\*=|\/=|\+\+|--)/g,
                    weight: 0.7,
                    description: 'Unchecked arithmetic block',
                    falsePositiveRisk: 0.15
                },
                // SafeMath usage
                {
                    regex: /using\s+SafeMath\s+for|\.add\(|\.sub\(|\.mul\(|\.div\(/g,
                    weight: 0.0,
                    description: 'SafeMath used - safe',
                    isFalsePositive: true
                }
            ],
            
            validate: function(code, match) {
                // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¥ØµØ¯Ø§Ø± Solidity
                const pragmaMatch = code.match(/pragma\s+solidity\s+([^;]+);/);
                if (pragmaMatch) {
                    const version = pragmaMatch[1];
                    if (version.includes('0.8') || parseFloat(version) >= 0.8) {
                        return { isTruePositive: false, reason: 'Solidity 0.8+ has built-in overflow protection' };
                    }
                }
                
                // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† SafeMath
                if (code.includes('SafeMath')) {
                    return { isTruePositive: false, reason: 'SafeMath library detected' };
                }
                
                return { isTruePositive: true, confidence: 0.85 };
            }
        },

        // ğŸ”µ Tx.Origin - Ø°ÙƒÙŠ
        txOrigin: {
            name: 'Tx.Origin Authentication',
            severity: 'critical',
            category: 'authentication',
            
            patterns: [
                {
                    regex: /require\s*\(\s*tx\.origin\s*==/g,
                    weight: 1.0,
                    description: 'Using tx.origin for authentication - CRITICAL',
                    falsePositiveRisk: 0.01
                },
                {
                    regex: /if\s*\(\s*tx\.origin\s*==/g,
                    weight: 0.9,
                    description: 'Conditional check with tx.origin',
                    falsePositiveRisk: 0.05
                },
                {
                    regex: /modifier[\s\S]*?require\s*\(\s*tx\.origin/g,
                    weight: 1.0,
                    description: 'Modifier using tx.origin - CRITICAL',
                    falsePositiveRisk: 0.01
                }
            ],
            
            validate: function(code, match) {
                // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ msg.solver Ø¨Ø¯ÙŠÙ„
                if (code.includes('msg.sender')) {
                    const context = code.substring(Math.max(0, match.index - 100), match.index + 100);
                    if (context.includes('msg.sender')) {
                        return { 
                            isTruePositive: true, 
                            confidence: 0.9,
                            note: 'Both tx.origin and msg.sender used - potential confusion'
                        };
                    }
                }
                
                // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ø³ØªØ®Ø¯Ø§Ù…Ù‡ ÙÙŠ Ø¯ÙˆØ§Ù„ Ù…Ø­Ø¯Ø¯Ø©
                const functionName = this.extractFunctionName(code, match.index);
                if (functionName && (functionName.includes('emergency') || functionName.includes('admin'))) {
                    return { 
                        isTruePositive: true, 
                        confidence: 0.95,
                        note: 'Critical function uses tx.origin'
                    };
                }
                
                return { isTruePositive: true, confidence: 0.85 };
            },
            
            extractFunctionName: function(code, index) {
                const beforeCode = code.substring(0, index);
                const functionMatch = beforeCode.match(/function\s+(\w+)\s*\(/g);
                if (functionMatch) {
                    return functionMatch[functionMatch.length - 1].replace('function ', '').replace('(', '');
                }
                return null;
            }
        },

        // ğŸŸ£ Front-Running - Ø°ÙƒÙŠ
        frontRunning: {
            name: 'Front-Running Vulnerability',
            severity: 'medium',
            category: 'transaction-ordering',
            
            patterns: [
                {
                    regex: /(?:guess|reveal|commit).*?\=.*?block\.(?:timestamp|number)/gis,
                    weight: 0.8,
                    description: 'Predictable randomness using block data',
                    falsePositiveRisk: 0.2
                },
                {
                    regex: /commit.*?reveal|reveal.*?commit/gis,
                    weight: 0.3,
                    description: 'Commit-reveal pattern detected - likely safe',
                    isFalsePositive: true
                },
                {
                    regex: /chainlink.*?VRF|randao|oracle/gis,
                    weight: 0.0,
                    description: 'Secure randomness source detected',
                    isFalsePositive: true
                }
            ],
            
            validate: function(code, match) {
                // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Commit-Reveal
                if (code.includes('commit') && code.includes('reveal')) {
                    return { 
                        isTruePositive: false, 
                        reason: 'Commit-reveal pattern properly implemented'
                    };
                }
                
                // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Chainlink VRF
                if (code.includes('VRFConsumerBase') || code.includes('VRFV2Wrapper')) {
                    return { 
                        isTruePositive: false, 
                        reason: 'Chainlink VRF provides secure randomness'
                    };
                }
                
                // ØªØ­Ù„ÙŠÙ„ Ø®Ø·ÙˆØ±Ø© Ø§Ù„Ø§Ø³ØªØºÙ„Ø§Ù„
                const bidFunctions = code.match(/function\s+(?:bid|swap|buy|claim)/g);
                if (bidFunctions && bidFunctions.length > 2) {
                    return { 
                        isTruePositive: true, 
                        confidence: 0.75,
                        note: 'Multiple value-claiming functions with predictable ordering'
                    };
                }
                
                return { isTruePositive: true, confidence: 0.6 };
            }
        },

        // ğŸŸ  DoS - Ø°ÙƒÙŠ
        denialOfService: {
            name: 'Denial of Service',
            severity: 'high',
            category: 'availability',
            
            patterns: [
                {
                    regex: /for\s*\([^;]*;[^;]*i\+\+\)\s*\{\s*(?:payable|transfer|send)/g,
                    weight: 0.9,
                    description: 'Loop with external calls - potential DoS',
                    falsePositiveRisk: 0.1
                },
                {
                    regex: /array\.push\s*\([^)]*\)[\s\S]*?for.*?\.length/g,
                    weight: 0.7,
                    description: 'Dynamic array with unbounded loop',
                    falsePositiveRisk: 0.15
                },
                {
                    regex: /require\s*\(\s*msg\.sender\s*==\s*owner\s*,\s*"[^"]*"\)\s*;[\s\S]*?selfdestruct/g,
                    weight: 0.95,
                    description: 'Single-owner selfdestruct - permanent DoS risk',
                    falsePositiveRisk: 0.05
                }
            ],
            
            validate: function(code, match) {
                // ØªØ­Ù„ÙŠÙ„ Ø­Ø¬Ù… Ø§Ù„Ù…ØµÙÙˆÙØ©
                const arrayMatch = code.match(/(\w+)\s*\[\s*\]\s*public\s+\w+/);
                if (arrayMatch) {
                    const arrayName = arrayMatch[1];
                    const pushMatch = new RegExp(`${arrayName}\\.push\\(`).test(code);
                    const loopMatch = new RegExp(`for.*?${arrayName}\\.length`).test(code);
                    
                    if (pushMatch && loopMatch) {
                        return { 
                            isTruePositive: true, 
                            confidence: 0.85,
                            note: 'Unbounded array with iteration'
                        };
                    }
                }
                
                // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† owner backup
                if (code.includes('selfdestruct') && !code.includes('multi') && !code.includes('timelock')) {
                    return { 
                        isTruePositive: true, 
                        confidence: 0.9,
                        note: 'Single point of failure for contract destruction'
                    };
                }
                
                return { isTruePositive: true, confidence: 0.7 };
            }
        },

        // ğŸŸ¢ Access Control - Ø¬Ø¯ÙŠØ¯
        accessControl: {
            name: 'Access Control Issues',
            severity: 'high',
            category: 'permissions',
            
            patterns: [
                {
                    regex: /function\s+\w+\s*\([^)]*\)\s*public[\s\S]*?(?:require|if)\s*\(\s*msg\.sender/g,
                    weight: 0.3,
                    description: 'Public function with sender check',
                    isFalsePositive: true
                },
                {
                    regex: /function\s+\w+\s*\([^)]*\)\s*public[\s\S]*?(?!require|if).*?(?:transfer|send|call|delegatecall)/g,
                    weight: 0.9,
                    description: 'Public function with no access control',
                    falsePositiveRisk: 0.1
                },
                {
                    regex: /delegatecall.*?tx\.origin/g,
                    weight: 1.0,
                    description: 'Delegatecall with tx.origin - CRITICAL',
                    falsePositiveRisk: 0.01
                }
            ],
            
            validate: function(code, match) {
                // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ onlyOwner modifier
                if (code.includes('onlyOwner') || code.includes('onlyAdmin')) {
                    const modifierPosition = code.indexOf('onlyOwner');
                    const functionEnd = code.indexOf('{', match.index);
                    
                    if (modifierPosition < functionEnd && modifierPosition > match.index) {
                        return { 
                            isTruePositive: false, 
                            reason: 'Access control modifier present'
                        };
                    }
                }
                
                return { isTruePositive: true, confidence: 0.8 };
            }
        },

        // ğŸŸ¤ Oracle Manipulation - Ø¬Ø¯ÙŠØ¯
        oracleManipulation: {
            name: 'Oracle Manipulation',
            severity: 'high',
            category: 'price-feeds',
            
            patterns: [
                {
                    regex: /(?:getReserve|getRatio|getPrice|spotPrice).*?[^C]?[^h]?[^a]?[^i]?[^n]?[^l]?[^i]?[^n]?[^k]/gi,
                    weight: 0.7,
                    description: 'Potential oracle manipulation - no Chainlink',
                    falsePositiveRisk: 0.2
                },
                {
                    regex: /chainlink|aggregator|latestAnswer|latestRoundData/gi,
                    weight: 0.0,
                    description: 'Chainlink oracle detected - secure',
                    isFalsePositive: true
                },
                {
                    regex: /uniswap.*?twap|oracle.*?twap/gi,
                    weight: 0.4,
                    description: 'TWAP oracle - relatively secure',
                    falsePositiveRisk: 0.3
                }
            ],
            
            validate: function(code, match) {
                // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† TWAP period
                if (code.includes('twap')) {
                    const periodMatch = code.match(/period\s*=\s*(\d+)/);
                    if (periodMatch) {
                        const period = parseInt(periodMatch[1]);
                        if (period >= 1800) { // 30 Ø¯Ù‚ÙŠÙ‚Ø©
                            return { 
                                isTruePositive: false, 
                                reason: 'TWAP with sufficient period'
                            };
                        }
                    }
                }
                
                return { isTruePositive: true, confidence: 0.65 };
            }
        }
    },

    // ========== 2. Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø§Ø³ØªØ¨Ø¹Ø§Ø¯ (False Positives) ==========
    falsePositiveDB: {
        // Ø¹Ù‚ÙˆØ¯ Ø¢Ù…Ù†Ø© Ù…Ø¹Ø±ÙˆÙØ©
        safeContracts: [
            'OpenZeppelin',
            'UniswapV2Pair',
            'UniswapV3Pool',
            'ERC20',
            'ERC721',
            'ReentrancyGuard',
            'SafeERC20'
        ],
        
        // Ø£Ù†Ù…Ø§Ø· Ø¢Ù…Ù†Ø©
        safePatterns: [
            'nonReentrant',
            'whenNotPaused',
            'onlyRole',
            'hasRole',
            '_msgSender',
            'SafeMath'
        ],
        
        // Ù…ÙƒØªØ¨Ø§Øª Ù…ÙˆØ«ÙˆÙ‚Ø©
        trustedLibraries: [
            '@openzeppelin/',
            '@chainlink/',
            '@uniswap/',
            '@aave/',
            '@compound-finance/'
        ]
    },

    // ========== 3. Ù†Ø¸Ø§Ù… Ø§Ù„ØªØ¹Ù„Ù… Ø§Ù„Ø°Ø§ØªÙŠ ==========
    learning: {
        // Ø³Ø¬Ù„ Ø§Ù„Ù‚Ø±Ø§Ø±Ø§Øª Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©
        decisionHistory: [],
        
        // Ø¥Ø¶Ø§ÙØ© Ù‚Ø±Ø§Ø± Ø¬Ø¯ÙŠØ¯
        addDecision: function(vulnerability, wasCorrect) {
            this.decisionHistory.push({
                timestamp: Date.now(),
                vulnerability: vulnerability,
                wasCorrect: wasCorrect,
                pattern: vulnerability.pattern
            });
            
            // ØªØ­Ø¯ÙŠØ« Ø§Ù„ÙˆØ²Ù† Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ø¯Ù‚Ø©
            if (this.decisionHistory.length > 100) {
                this.adjustWeights();
            }
        },
        
        // ØªØ¹Ø¯ÙŠÙ„ Ø£ÙˆØ²Ø§Ù† Ø§Ù„Ø£Ù†Ù…Ø§Ø·
        adjustWeights: function() {
            const patternStats = {};
            
            this.decisionHistory.forEach(decision => {
                const pattern = decision.pattern;
                if (!patternStats[pattern]) {
                    patternStats[pattern] = { correct: 0, total: 0 };
                }
                
                patternStats[pattern].total++;
                if (decision.wasCorrect) {
                    patternStats[pattern].correct++;
                }
            });
            
            // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø£ÙˆØ²Ø§Ù† ÙÙŠ patterns
            for (const [category, vuln] of Object.entries(this.patterns)) {
                vuln.patterns.forEach(p => {
                    if (patternStats[p.regex]) {
                        const accuracy = patternStats[p.regex].correct / patternStats[p.regex].total;
                        p.weight *= accuracy;
                        p.falsePositiveRisk = 1 - accuracy;
                    }
                });
            }
        }
    },

    // ========== 4. ÙˆØ¸Ø§Ø¦Ù Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© Ø§Ù„Ø°ÙƒÙŠØ© ==========
    helpers: {
        // ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø³ÙŠØ§Ù‚
        analyzeContext: function(code, index, radius = 200) {
            const start = Math.max(0, index - radius);
            const end = Math.min(code.length, index + radius);
            return code.substring(start, end);
        },
        
        // Ø§ÙƒØªØ´Ø§Ù Ù†Ù…Ø· Ø§Ù„Ø¥ØµÙ„Ø§Ø­
        detectMitigation: function(code, vulnerability) {
            const mitigations = {
                reentrancy: ['nonReentrant', 'ReentrancyGuard', 'checks-effects-interactions'],
                overflow: ['SafeMath', 'pragma solidity ^0.8.0', 'unchecked'],
                txorigin: ['msg.sender'],
                frontrun: ['commit', 'reveal', 'VRF'],
                dos: ['pull over push', 'withdraw pattern']
            };
            
            const suggestions = mitigations[vulnerability.category] || [];
            return suggestions.filter(s => !code.includes(s));
        },
        
        // Ø­Ø³Ø§Ø¨ Ø§Ù„Ø«Ù‚Ø©
        calculateConfidence: function(match, context, vuln) {
            let confidence = vuln.weight;
            
            // Ø®ÙØ¶ Ø§Ù„Ø«Ù‚Ø© Ø¥Ø°Ø§ ÙƒØ§Ù† ÙÙŠ Ù…ÙƒØªØ¨Ø© Ù…ÙˆØ«ÙˆÙ‚Ø©
            if (context.includes('@openzeppelin') || context.includes('@chainlink')) {
                confidence *= 0.1;
            }
            
            // Ø±ÙØ¹ Ø§Ù„Ø«Ù‚Ø© Ø¥Ø°Ø§ ÙƒØ§Ù† ÙÙŠ Ø¯ÙˆØ§Ù„ Ø­Ø±Ø¬Ø©
            if (context.includes('withdraw') || context.includes('transfer') || context.includes('mint')) {
                confidence *= 1.2;
            }
            
            return Math.min(confidence, 1.0);
        }
    },

    // ========== 5. ÙˆØ¸ÙŠÙØ© Ø§Ù„Ù…Ø³Ø­ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© ==========
    scan: function(code, fileName = '', context = {}) {
        const findings = [];
        const startTime = Date.now();
        
        // ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ù…ÙƒØªØ¨Ø§Øª Ø§Ù„Ù…ÙˆØ«ÙˆÙ‚Ø©
        if (this.falsePositiveDB.trustedLibraries.some(lib => fileName.includes(lib))) {
            return { findings: [], trusted: true };
        }
        
        // Ù…Ø³Ø­ ÙƒÙ„ Ø§Ù„Ø£Ù†Ù…Ø§Ø·
        for (const [vulnType, vuln] of Object.entries(this.patterns)) {
            for (const pattern of vuln.patterns) {
                // ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ø£Ù†Ù…Ø§Ø· Ø§Ù„Ù…Ø¹Ø±ÙˆÙØ© Ø¨Ø£Ù†Ù‡Ø§ False Positive
                if (pattern.isFalsePositive) continue;
                
                const matches = code.matchAll(pattern.regex);
                
                for (const match of matches) {
                    // ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø³ÙŠØ§Ù‚
                    const context_ = this.helpers.analyzeContext(code, match.index);
                    
                    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ø«ØºØ±Ø©
                    let isValid = true;
                    let confidence = pattern.weight;
                    let reason = '';
                    
                    if (vuln.validate) {
                        const validation = vuln.validate(code, match);
                        isValid = validation.isTruePositive;
                        confidence = validation.confidence || pattern.weight;
                        reason = validation.reason || '';
                    }
                    
                    // ØªØ¬Ø§Ù‡Ù„ False Positives
                    if (!isValid || confidence < 0.3) continue;
                    
                    // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† ÙˆØ¬ÙˆØ¯ Ø¥ØµÙ„Ø§Ø­Ø§Øª
                    const mitigations = this.helpers.detectMitigation(code, vuln);
                    const isMitigated = mitigations.length === 0;
                    
                    // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø«ØºØ±Ø©
                    findings.push({
                        id: `${vulnType}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                        type: vulnType,
                        name: vuln.name,
                        severity: vuln.severity,
                        category: vuln.category,
                        description: pattern.description,
                        confidence: Math.round(confidence * 100),
                        lineNumber: this.helpers.findLineNumber(code, match.index),
                        match: match[0],
                        context: context_.substring(0, 150) + '...',
                        isMitigated: isMitigated,
                        suggestedFix: mitigations[0] || 'Review and apply security pattern',
                        falsePositiveRisk: pattern.falsePositiveRisk,
                        timestamp: Date.now()
                    });
                }
            }
        }
        
        // ØªØ±ØªÙŠØ¨ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø­Ø³Ø¨ Ø§Ù„Ø«Ù‚Ø©
        findings.sort((a, b) => b.confidence - a.confidence);
        
        // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ØªÙƒØ±Ø§Ø±Ø§Øª
        const uniqueFindings = this.deduplicate(findings);
        
        return {
            findings: uniqueFindings,
            stats: {
                scanTime: Date.now() - startTime,
                totalFindings: uniqueFindings.length,
                critical: uniqueFindings.filter(f => f.severity === 'critical').length,
                high: uniqueFindings.filter(f => f.severity === 'high').length,
                medium: uniqueFindings.filter(f => f.severity === 'medium').length,
                mitigated: uniqueFindings.filter(f => f.isMitigated).length
            }
        };
    },
    
    // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ØªÙƒØ±Ø§Ø±Ø§Øª
    deduplicate: function(findings) {
        const seen = new Set();
        return findings.filter(f => {
            const key = `${f.type}_${f.lineNumber}_${f.match}`;
            if (seen.has(key)) return false;
            seen.add(key);
            return true;
        });
    },
    
    // ØªÙˆÙ„ÙŠØ¯ ØªÙ‚Ø±ÙŠØ± Ø°ÙƒÙŠ
    generateReport: function(scanResults) {
        return {
            summary: {
                totalVulnerabilities: scanResults.stats.totalFindings,
                criticalIssues: scanResults.stats.critical,
                highIssues: scanResults.stats.high,
                mediumIssues: scanResults.stats.medium,
                mitigatedIssues: scanResults.stats.mitigated
            },
            
            criticalFindings: scanResults.findings.filter(f => f.severity === 'critical'),
            
            recommendations: this.generateRecommendations(scanResults.findings),
            
            riskLevel: this.calculateRiskLevel(scanResults.stats),
            
            falsePositiveAnalysis: this.analyzeFalsePositives(scanResults.findings)
        };
    },
    
    // ØªØ­Ù„ÙŠÙ„ False Positives
    analyzeFalsePositives: function(findings) {
        const highRiskFP = findings.filter(f => f.confidence > 80 && !f.isMitigated);
        const lowRiskFP = findings.filter(f => f.confidence < 50 || f.isMitigated);
        
        return {
            highConfidenceFindings: highRiskFP.length,
            lowConfidenceFindings: lowRiskFP.length,
            needsReview: highRiskFP
        };
    },
    
    // Ø­Ø³Ø§Ø¨ Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø®Ø·ÙˆØ±Ø©
    calculateRiskLevel: function(stats) {
        if (stats.critical > 0) return 'CRITICAL';
        if (stats.high > 2) return 'HIGH';
        if (stats.high > 0) return 'MEDIUM';
        if (stats.medium > 3) return 'LOW';
        return 'MINIMAL';
    },
    
    // ØªÙˆÙ„ÙŠØ¯ ØªÙˆØµÙŠØ§Øª
    generateRecommendations: function(findings) {
        const recommendations = [];
        
        findings.forEach(f => {
            if (!f.isMitigated && f.confidence > 70) {
                recommendations.push({
                    vulnerability: f.name,
                    severity: f.severity,
                    location: `Line ${f.lineNumber}`,
                    action: f.suggestedFix,
                    priority: f.severity === 'critical' ? 'IMMEDIATE' : 'SCHEDULED'
                });
            }
        });
        
        return recommendations;
    }
};

// ØªØµØ¯ÙŠØ± Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…
window.ShrekVulnerabilityDB = ShrekVulnerabilityDB;
